layout custom_lines


	code metapost

		## redefinitions of existing line styles

	    # simple black line
		def l_contour_MY (expr P)(text txt) =
	  		T:=identity;
	  		pickup PenC;
	  		thdraw P;
		enddef;

    	# grey centreline
		def l_survey_cave_MY (expr P) =
		  T:=identity;
		  draw P withpen PenD withcolor (0.7,0.7,0.7);
		enddef;

		# wall debris
		def l_wall_debris_MY (expr P)=
      		T:=identity;
      		cas := 0;
      		dlzka := arclength P;
      		if dlzka > 0:
      			mojkrok:=adjust_step(dlzka, 0.2u);
      			pickup PenC;
      			forever:
      				t_0 := arctime(cas) of P;
      				t_end := arctime(cas+mojkrok) of P;
      				t1 := arctime (cas + (3+0.5*normaldeviate)/10*mojkrok) of P;
      				t2 := arctime (cas + (8-0.5*normaldeviate)/10*mojkrok) of P;
      				t3 := arctime (cas + (6+0.5*normaldeviate)/10*mojkrok) of P;
      				sk := 1-.25*normaldeviate;
      				q := (point t_0 of P + .02*sk*u * unitvector(thdir(P,t_0))) ..
      				((point t1 of P) - .06*sk*u * unitvector(thdir(P,t1) rotated (88+normaldeviate*2))) ..
      				((point t2 of P) + .03*sk*u * unitvector(thdir(P,t2) rotated (-20+normaldeviate*2))) .. ((point t3 of P) - .07*sk*u *unitvector(thdir(P,t3) rotated (-20+normaldeviate*2))) .. cycle;

      				thclean q;
      				thfill q withcolor(0.7,0.3,0.2);
      				cas := cas + mojkrok;
      				exitif cas > dlzka - (2*mojkrok/3); % for rounding errors
      			endfor;
      		fi;
    	enddef;

		def l_wall_clay_MYEE (expr P)=
      		T:=identity;
      		cas := 0;
      		dlzka := arclength P;
      		if dlzka > 0:
      			mojkrok:=adjust_step(dlzka, 0.2u);
      			pickup PenC;
      			forever:
      				t_0 := arctime(cas) of P;
      				t_end := arctime(cas+mojkrok) of P;
      				t1 := arctime (cas + (3+0.5*normaldeviate)/10*mojkrok) of P;
      				t2 := arctime (cas + (8-0.5*normaldeviate)/10*mojkrok) of P;
      				t3 := arctime (cas + (6+0.5*normaldeviate)/10*mojkrok) of P;
      				sk := 1-.25*normaldeviate;
      				q := (point t_0 of P + .02*sk*u * unitvector(thdir(P,t_0))) ..
      				((point t1 of P) - .06*sk*u * unitvector(thdir(P,t1) rotated (88+normaldeviate*2))) ..
      				((point t2 of P) + .03*sk*u * unitvector(thdir(P,t2) rotated (-20+normaldeviate*2))) .. ((point t3 of P) - .07*sk*u *unitvector(thdir(P,t3) rotated (-20+normaldeviate*2))) .. cycle;

      				thclean q;
      				thfill q withcolor(0.7,0.3,0.2);
      				cas := cas + mojkrok;
      				exitif cas > dlzka - (2*mojkrok/3); % for rounding errors
      			endfor;
      		fi;
    	enddef;



		# grey rock borders
		def l_rockborder_MY (expr P) =
		  T:=identity;
		  pickup PenC;
		  if cycle P: thclean P fi;
		  thdraw P withcolor (0.3,0.3,0.3);
		enddef;

		# orange wall line with chevrons
		def l_wall_flowstone (expr P) =
		  T:=identity;
		  cas := 0;
		  dlzka := arclength P;
		  mojkrok:=adjust_step(dlzka, .75u);
		  pickup PenC;
		  p := (-.25u,-.05u)--(-.175u,.05u)--(-.1u,-.05u);
		  q := (-.025u,-.05u)--(.05u,.05u)--(0.125u,-.05u);
		  forever:
		    t := arctime (cas + mojkrok/2) of P;
		    thdraw p shifted (point t of P + .25u * unitvector(thdir(P,t) rotated -90)) withcolor(0.85,0.45,0.1);
		    thdraw q shifted (point t of P + .25u * unitvector(thdir(P,t) rotated -90)) withcolor(0.85,0.45,0.1);
		    cas := cas + mojkrok;
		    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors
		  endfor;
		  pickup PenA;
		  thdraw P withcolor(1,0.5,0.1);
		enddef;

		# extended view definition of wall blocks
		 def l_wall_blocks_MYEE (expr P)=
      		T:=identity;
      		cas := 0;
      		dlzka := arclength P;
      		if dlzka > 0:
      			mojkrok:=adjust_step(dlzka, 0.3u);
      			pickup PenD;
      			forever:
      				t_0 := arctime(cas) of P;
      				t_end := arctime(cas+mojkrok) of P;
      				t1 := arctime (cas + (2+1.3*normaldeviate)/10*mojkrok) of P;
      				t2 := arctime (cas + (8-1.2*normaldeviate)/10*mojkrok) of P;
      				t3 := arctime (cas + (2.5+1.2*normaldeviate)/10*mojkrok) of P;
      				t4 := arctime (cas + (8.5-1.3*normaldeviate)/10*mojkrok) of P;
      				sk := 1-.25*normaldeviate;
      				q := (point t_0 of P) -- ((point t1 of P) + .05*sk*u * unitvector(thdir(P,t1) rotated (-88+normaldeviate*4))) --
      		((point t2 of P) + .05*sk*u * unitvector(thdir(P,t2) rotated (-88+normaldeviate*4))) -- (point t_end of P) -- ((point t4 of P) - .1*sk*u * unitvector(thdir(P,t4) rotated (-88+normaldeviate*4))) --
      		((point t3 of P) - .1*sk*u * unitvector(thdir(P,t3) rotated (-88+normaldeviate*4))) -- cycle;

      				thdraw q withcolor(0.3,0.3,0.3);
      				cas := cas + mojkrok;
      				exitif cas > dlzka - (2*mojkrok/3); % for rounding errors
      			endfor;
      		fi;
    	enddef;


		# plan view defition of wall blocks is Austrian style, but grey
		def l_wall_blocks_MY (expr P)=
		  T:=identity;
		  cas := 0;
		  dlzka := arclength P;
			if dlzka > 0:
		  	mojkrok:=adjust_step(dlzka, 0.5u);
		  	pickup PenC;
		  	forever:
		    	t1 := arctime (cas + mojkrok*1/10) of P;
		    	t2 := arctime (cas + mojkrok*9/10) of P;
		    	q := ((point t1 of P) + .2u * unitvector(thdir(P,t1) rotated -125)) --
		         (subpath (t1,t2) of P) --
		         ((point t2 of P) + .2u * unitvector(thdir(P,t2) rotated -75));

		    	thdraw q randomized (u/12) withcolor(0.3,0.3,0.3);
		    	cas := cas + mojkrok;
		    	exitif cas > dlzka - (2*mojkrok/3); % for rounding errors
		  	endfor;
			fi;
		enddef;

		# blue wall line with perpendicular dashes
		def l_wall_ice_MY (expr P) =
		  	T:=identity;
		  	cas := 0;
		  	dlzka := arclength P;
		  	mojkrok:=adjust_step(dlzka, .9u);
		  	pickup PenC;
		  	p := (0,-0.15u)--(0,0.15u);
		  	forever:
		    	t1 := arctime (cas + mojkrok/6) of P;
		    	t2 := arctime (cas + mojkrok*2/6) of P;
		    	t3 := arctime (cas + mojkrok*3/6) of P;
		    	t5 := arctime (cas + mojkrok*5/6) of P;
		    	q := subpath(t1,t3) of P;
		    	p := (point t5 of P + .45u * unitvector(thdir(P,t5) rotated -90))--
		    	  (point t5 of P + .2u * unitvector(thdir(P,t5) rotated -90));
		    	thdraw q shifted ( .3u * unitvector(thdir(P,t2) rotated -90)) withcolor(0,0.7,0.9);
		    	thdraw p  withcolor(0,0.7,0.9);
		    	cas := cas + mojkrok;
		    	exitif cas > dlzka - (2*mojkrok/3); % for rounding errors
		  	endfor;
		  	pickup PenA;
		  	thdraw P withcolor(0,0.7,0.9);
		enddef;

		# initialise redefined symbols
		initsymbol("l_wall_blocks_MYEE");
	    initsymbol("l_wall_blocks_MY");
	    initsymbol("l_wall_debris_MY");
	    initsymbol("l_wall_ice_MY");
	    initsymbol("l_wall_flowstone");
	    initsymbol("l_rockborder_MY");
	    initsymbol("l_survey_cave_MY");
		initsymbol("l_wall_clay_MYEE");
	    initsymbol("l_contour_MY");

        # grey dashed line
    	def l_u_fault (expr P)=
    		T:=identity;
    		pickup PenC;
    	  thdraw P withcolor (0.5,0.5,0.5) dashed evenly scaled (2*optical_zoom);
    	enddef;

		 # grey dashed line
    	def l_u_icepresumed (expr P)=
    		T:=identity;
    		pickup PenC;
    	  thdraw P withcolor (0.,0.7,0.9) dashed evenly scaled (2*optical_zoom);
    	enddef;

    	# blueish overlay line
    	def l_u_overlay_MY (expr P)=
    		T:=identity;
    		pickup PenA;
    		thdraw P withcolor (0.5,0.75,0.95);
    	enddef;

    	# grey overlay line
    	def l_u_underlay_MY (expr Path)=
    	  T:=identity;
    	  pickup PenA;
    	  thdraw Path withcolor(0.55,0.55,0.55);
    	enddef;

    	# a pinkish line
    	def l_u_mine_MY (expr Path)=
    	  T:=identity;
    	  pickup PenA;
    	  thdraw Path withcolor(0.82,0.55,0.82);
    	enddef;

    	# a thin grey, dashed line
    	def l_u_dripline (expr Path)=
    	  T:=identity;
    	  pickup PenC;
    	  thdraw Path withcolor (0.25,0.25,0.25) dashed evenly scaled (1*optical_zoom);
    	enddef;

			# a thick, blue dashed line
    	def l_u_oldsnow_MY (expr Path)=
    	  T:=identity;
    	  pickup PenA;
    	  thdraw Path withcolor (0,0.7,0.9) dashed evenly scaled (1*optical_zoom);
    	enddef;


		 % store the original clean_legend_box
  boolean l_rope_MY_inlegend;
  l_rope_MY_inlegend:=false;
  let l_rope_MY_legend_box = clean_legend_box;
  % redefine clean_legend_box to store the flag, then run the original
  def clean_legend_box =
    l_rope_MY_inlegend:=true;
    l_rope_MY_legend_box;
  enddef;

  def l_rope(expr P, show_anchors, show_rebelays)=
    T:=identity;
    pickup PenB;
    if l_rope_MY_inlegend:
      % drawing the legend - this gets run twice, since Therion draws two ropes, one for each parameter
      if show_rebelays:
        thdraw ((.35,.9) -- (.4,.85) -- (.4,.5) .. controls (.4,.4) and (.45,.4) .. (.5,.5) -- (.55,.45) -- (.55,.1)) inscale;
        thdraw ((.4,.85) -- (.45,.9)) inscale;
        thdraw ((.55,.45) -- (.6,.5)) inscale;
        thfill fullcircle scaled .15u shifted ((.35,.9) inscale);
        thfill fullcircle scaled .15u shifted ((.45,.9) inscale);
        thfill fullcircle scaled .15u shifted ((.5,.5) inscale);
        thfill fullcircle scaled .15u shifted ((.6,.5) inscale);
      fi;
    else:
      begingroup;
        save type;
        string type;
        if known ATTR_type:
          type:=ATTR_type;
        else:
          type:="primary";
        fi;
        if type = "secondary":
          thdraw P withcolor (0.7, 0.7, 0.7);
        else:
          thdraw P;
        fi;
      endgroup;
    fi;
  	enddef;

	def l_u_deviation (expr P) =
    begingroup;
      save ellipse;
      T:=identity;
      pickup PenC;
      path ellipse;
      ellipse:=fullcircle xscaled (.5u) yscaled (.25u) shifted (point (length P) of P);
      thdraw P cutafter ellipse;
      draw ellipse;
    endgroup;
  enddef;
  initsymbol("l_u_deviation");
  def l_u_deviation_legend =
    l_u_deviation(((.1,.5)--(.8,.5)) inscale);
  enddef;

    	# thin grey line
    	def l_u_texture (expr P)=
    	  T:=identity;
    	  thdraw P withpen PenD withcolor (0.3,0.3,0.3);
    	enddef;

    	# line made of orange crescents for flowstone inside a passage
    	def l_u_wall_flowstone (expr P)=
    	  T:=identity;
    	  cas := 0;
    	  dlzka := arclength P;
    	  if dlzka > 0:
    	    mojkrok:=adjust_step(dlzka, 0.5u);
    	    pickup PenC;
    	    forever:
    	      t1 := arctime (cas + mojkrok*2.5/10) of P;
    	      t1b := arctime (cas + mojkrok*4/10) of P;
    	      t2 := arctime (cas + mojkrok*7.5/10) of P;
    	      t2b := arctime (cas + mojkrok*6/10) of P;
    	      t2a :=arctime (cas +mojkrok*7.49/10) of P;

    	      q := ((point t1 of P) + 0.05u * unitvector(thdir(P,t1) rotated -115)) ..
    	            ((point t1b of P) - .01u * unitvector(thdir(P,t1b) rotated -90)) ..
    	           ((point t2b of P) - .01u * unitvector(thdir(P,t1b) rotated -90)) ..
    	           ((point t2 of P) + .05u * unitvector(thdir(P,t2) rotated -65))--
    	           ((point t2a of P) + .05u * unitvector(thdir(P,t2a) rotated -65)) ..
    	           ((point t2b of P) + .01u * unitvector(thdir(P,t1b) rotated -90)) ..
    	           ((point t1b of P) + .01u * unitvector(thdir(P,t1b) rotated -90)) ..
    	           ((point t1 of P) + .05u * unitvector(thdir(P,t1) rotated -115));

    	      thdraw q withcolor(0.85,0.45,0.1);
    	      cas := cas + mojkrok;
    	      exitif cas > dlzka - (2*mojkrok/3); % for rounding errors
    	    endfor;
    	  fi;
    	enddef;

    	 def l_u_wallstep (expr P) =
    	  T:=identity;
    	  laenge:= arclength P;
    	  symsize:=adjust_step(laenge,0.12u);
				offset:= symsize*1.5;
    	  ministep:=offset/5;
    	  cur:=0;
    	  pickup PenC;

    	  forever:
    	    t0 := arctime (cur) of P;
    	    t1 := arctime (cur+ministep) of P;
    	    t2 := arctime (cur+2*ministep) of P;
    	    t3a := arctime (cur+3*ministep) of P;
    	    t4 := arctime (cur+4*ministep) of P;
    	    t5 := arctime (cur+5*ministep) of P;

    	    thclean (subpath (t5,t0) of P) -- ((point t0 of P) + symsize * unitvector(thdir(P,t0) rotated 90)) ..
    	    ((point t1 of P) + symsize * unitvector(thdir(P,t1) rotated 90)) ..
    	    ((point t2 of P) + symsize * unitvector(thdir(P,t2) rotated 90)) ..
    	    ((point t3a of P) + symsize * unitvector(thdir(P,t3a) rotated 90)) ..
    	    ((point t4 of P) + symsize * unitvector(thdir(P,t4) rotated 90)) ..
    	    ((point t5 of P) + symsize * unitvector(thdir(P,t5) rotated 90))--cycle;

    	    thdraw ((point t0 of P) + symsize * unitvector(thdir(P,t0) rotated 90)) ..
    	    ((point t1 of P) + symsize * unitvector(thdir(P,t1) rotated 90)) ..
    	    ((point t2 of P) + symsize * unitvector(thdir(P,t2) rotated 90)) ..
    	    ((point t3a of P) + symsize * unitvector(thdir(P,t3a) rotated 90)) ..
    	    ((point t4 of P) + symsize * unitvector(thdir(P,t4) rotated 90)) ..
    	    ((point t5 of P) + symsize * unitvector(thdir(P,t5) rotated 90)) withpen PenC;

    	    thdraw ((point t3a of P) + symsize * unitvector(thdir(P,t3a) rotated 90)) --
    	    ((point t3a of P) + 7/4*symsize * unitvector(thdir(P,t3a) rotated 90)) withpen PenD;

    	    cur := cur + offset;
    	    exitif cur > laenge - (1*symsize/3); % for rounding errors
    	  endfor;
    	  pickup PenA;
    	  thdraw P;
    	enddef;

    	def l_u_bigpit_MY (expr P) =
  			T:=identity;
    	    laenge:= arclength P;
    	    symsize:=adjust_step(laenge,0.5u);
    	    triangle_width:=symsize/2;
    	    cur:=(symsize-triangle_width)/2;
    	    pickup PenC;
    	    forever:
    	      t1 := arctime (cur) of P;
    	      t  := arctime (cur + triangle_width/2) of P;
    	      t2 := arctime (cur + triangle_width) of P;
    	      if ATTR__height >= 10:
    	        thfill (subpath (t1,t2) of P) --
    	          ((point t of P) + symsize/2 * unitvector(thdir(P,t) rotated 90)) --
    	          cycle;
    	      else:
    	        thclean (subpath (t1,t2) of P) --
    	          ((point t of P) + symsize/2 * unitvector(thdir(P,t) rotated 90)) --
    	          cycle;
    	        thfill (point t2 of P) --((point t of P) + symsize/2 * unitvector(thdir(P,t) rotated 90)) --
    	          (point t1 of P)--cycle;
    	      fi;
    	      cur := cur + symsize;
    	      exitif cur > laenge - (1*symsize/3); % for rounding errors
    	      t1:=arctime (cur) of P;
    	    endfor;
    	    thdraw P;
    	  enddef;

    	def l_u_icestep_MY (expr P) =
      		T:=identity;
      		laenge:= arclength P;
      		symsize:=adjust_step(laenge,0.25u);
      		ministep:=symsize/5;
      		cur:=0;
      		pickup PenC;
      		forever:
        		t0 := arctime (cur) of P;
        		t1 := arctime (cur+ministep) of P;
        		t2 := arctime (cur+2*ministep) of P;
        		t3a := arctime (cur+3*ministep) of P;
        		t4 := arctime (cur+4*ministep) of P;
        		t5 := arctime (cur+5*ministep) of P;

        		%thclean (subpath (t5,t0) of P) --
        		%		 ((point t0 of P) + symsize/2 * unitvector(thdir(P,t0) rotated 90)) ..
        		%((point t1 of P) + symsize/2 * unitvector(thdir(P,t1) rotated 90)) ..
        		%((point t2 of P) + symsize/2 * unitvector(thdir(P,t2) rotated 90)) ..
        		%((point t3a of P) + symsize/2 * unitvector(thdir(P,t3a) rotated 90)) ..
        		%((point t4 of P) + symsize/2 * unitvector(thdir(P,t4) rotated 90)) ..
        		%((point t5 of P) + symsize/2 * unitvector(thdir(P,t5) rotated 90))--cycle;

        		thdraw P withcolor (0, 0.7,0.9);
        		thdraw (point t3a of P)  --
        		((point t3a of P) + 2/3*symsize * unitvector(thdir(P,t3a) rotated 90))
        		withpen PenC withcolor (0, 0.7,0.9);

        		cur := cur + symsize;
        		exitif cur > laenge - (1*symsize/3); % for rounding errors
      		endfor;
    	enddef;

			def l_pit_MY (expr P) =
				T:=identity;
					laenge:= arclength P;
					symsize:=adjust_step(laenge,0.25u);
					triangle_width:=symsize/2;
					cur:=(symsize-triangle_width)/2;
					pickup PenC;
					forever:
						t1 := arctime (cur) of P;
						t  := arctime (cur + triangle_width/2) of P;
						t2 := arctime (cur + triangle_width) of P;
						if ATTR__height >= 10:
							thfill (subpath (t1,t2) of P) --
								((point t of P) + symsize/2 * unitvector(thdir(P,t) rotated 90)) --
								cycle;
						else:
							thclean (subpath (t1,t2) of P) --
								((point t of P) + symsize/2 * unitvector(thdir(P,t) rotated 90)) --
								cycle;
							thfill (point t2 of P) --((point t of P) + symsize/2 * unitvector(thdir(P,t) rotated 90)) --
								(point t1 of P)--cycle;
						fi;
						cur := cur + symsize;
						exitif cur > laenge - (1*symsize/3); % for rounding errors
						t1:=arctime (cur) of P;
					endfor;
					thdraw P;
				enddef;

				initsymbol("l_pit_MY");

				def l_floorstep_MY (expr P) =
				  T:=identity;
				  cas := 0;
				  dlzka := arclength P;
				  mojkrok:=adjust_step(dlzka, 0.141u);
				  pickup PenD;
				  forever:
				    t := arctime cas of P;
				    mark_ (P,t,0.08u);
				    cas := cas + mojkrok;
				    exitif cas > dlzka + (mojkrok / 3); % for rounding errors
				  endfor;
				  pickup PenC;
				  thdraw P;
				enddef;

				initsymbol("l_floorstep_MY");


		 def l_u_wallbigpit (expr P) =
    	   T:=identity;
    	   laenge:= arclength P;
    	   symsize:=adjust_step(laenge,0.2u);
    	   ministep:=symsize/5;
    	   cur:=0;
    	   pickup PenC;
    	   forever:
    	     t0 := arctime (cur) of P;
    	     t1 := arctime (cur+ministep) of P;
    	     t2 := arctime (cur+2*ministep) of P;
    	     t3a := arctime (cur+3*ministep) of P;
    	     t4 := arctime (cur+4*ministep) of P;
    	     t5 := arctime (cur+5*ministep) of P;

    	     thclean (subpath (t5,t0) of P) -- ((point t0 of P) + symsize/2 * unitvector(thdir(P,t0) rotated 90)) ..
    	     ((point t1 of P) + symsize/2 * unitvector(thdir(P,t1) rotated 90)) ..
    	     ((point t2 of P) + symsize/2 * unitvector(thdir(P,t2) rotated 90)) ..
    	     ((point t3a of P) + symsize/2 * unitvector(thdir(P,t3a) rotated 90)) ..
    	     ((point t4 of P) + symsize/2 * unitvector(thdir(P,t4) rotated 90)) ..
    	     ((point t5 of P) + symsize/2 * unitvector(thdir(P,t5) rotated 90))--cycle;

    	     thdraw ((point t0 of P) + 3*symsize/5 * unitvector(thdir(P,t0) rotated 90)) ..
    	     ((point t1 of P) + 3*symsize/5 * unitvector(thdir(P,t1) rotated 90)) ..
    	     ((point t2 of P) + 3*symsize/5 * unitvector(thdir(P,t2) rotated 90)) ..
    	     ((point t3a of P) + 3*symsize/5 * unitvector(thdir(P,t3a) rotated 90)) ..
    	     ((point t4 of P) + 3*symsize/5 * unitvector(thdir(P,t4) rotated 90)) ..
    	     ((point t5 of P) + 3*symsize/5 * unitvector(thdir(P,t5) rotated 90));

    	     thfill ((point t2 of P) + 3*symsize/5 * unitvector(thdir(P,t2) rotated 90)) --
    	     ((point t3a of P) + symsize * unitvector(thdir(P,t3a) rotated 90)) --
    	     ((point t4 of P) + 3*symsize/5 * unitvector(thdir(P,t4) rotated 90)) ..
    	     ((point t3a of P) + 3*symsize/5 * unitvector(thdir(P,t3a) rotated 90)) .. cycle withpen PenD;

    	     #thdraw ((point t2 of P) + symsize/2 * unitvector(thdir(P,t2) rotated 90)) --
    	    #((point t3a of P) + symsize * unitvector(thdir(P,t3a) rotated 90)) --
    	     #((point t4 of P) + symsize/2 * unitvector(thdir(P,t4) rotated 90)) withpen PenD;

    	     cur := cur + symsize;
    	     exitif cur > laenge - (1*symsize/3); % for rounding errors
    	   endfor;
    	   pickup PenA;
    	   thdraw P;
    	 enddef;

		 def l_u_icewallbigpit (expr P) =
    	   T:=identity;
    	   laenge:= arclength P;
    	   symsize:=adjust_step(laenge,0.5u);
    	   ministep:=symsize/5;
    	   cur:=0;
    	   pickup PenC;
    	   forever:
    	     t0 := arctime (cur) of P;
    	     t1 := arctime (cur+ministep) of P;
    	     t2 := arctime (cur+2*ministep) of P;
    	     t3a := arctime (cur+3*ministep) of P;
    	     t4 := arctime (cur+4*ministep) of P;
    	     t5 := arctime (cur+5*ministep) of P;


    	     thdraw ((point t0 of P) + symsize/4 * unitvector(thdir(P,t0) rotated 90)) ..
    	     ((point t1 of P) + symsize/4 * unitvector(thdir(P,t1) rotated 90)) ..
    	     ((point t2 of P) + symsize/4 * unitvector(thdir(P,t2) rotated 90)) ..
    	     ((point t3a of P) + symsize/4 * unitvector(thdir(P,t3a) rotated 90)) ..
    	     ((point t4 of P) + symsize/4 * unitvector(thdir(P,t4) rotated 90)) ..
    	     ((point t5 of P) + symsize/4 * unitvector(thdir(P,t5) rotated 90)) withcolor(0,0.7,0.9);

    	     thfill ((point t2 of P) + symsize/4 * unitvector(thdir(P,t2) rotated 90)) --
    	     ((point t3a of P) + 3/4*symsize * unitvector(thdir(P,t3a) rotated 90)) --
    	     ((point t4 of P) + symsize/4 * unitvector(thdir(P,t4) rotated 90)) ..
    	     ((point t3a of P) + symsize/4 * unitvector(thdir(P,t3a) rotated 90)) .. cycle withpen PenC withcolor(0,0.7,0.9);

    	     thdraw ((point t2 of P) + symsize/4 * unitvector(thdir(P,t2) rotated 90)) --
    	     ((point t3a of P) + 3/4*symsize * unitvector(thdir(P,t3a) rotated 90)) --
    	     ((point t4 of P) + symsize/4 * unitvector(thdir(P,t4) rotated 90)) withpen PenC withcolor(0,0.7,0.9);

    	     cur := cur + symsize;
    	     exitif cur > laenge - (1*symsize/3); % for rounding errors
    	   endfor;
    	   pickup PenA;
    	   thdraw P withcolor(0,0.7,0.9);
    	 enddef;

    	def l_u_icepit_MY (expr P) =
    	    T:=identity;
    	    laenge:= arclength P;
    	    symsize:=adjust_step(laenge,0.5u);
    	    triangle_width:=symsize/2;
    	    cur:=(symsize-triangle_width)/2;
    	    pickup PenC;
    	    forever:
    	      t1 := arctime (cur) of P;
    	      t  := arctime (cur + triangle_width/2) of P;
    	      t2 := arctime (cur + triangle_width) of P;
    	      if ATTR__height >= 10:
    	        thfill (subpath (t1,t2) of P) --
    	          ((point t of P) + symsize/2 * unitvector(thdir(P,t) rotated 90)) --
    	          cycle;
    	      else:
    	        thclean (subpath (t1,t2) of P) --
    	          ((point t of P) + symsize/2 * unitvector(thdir(P,t) rotated 90)) --
    	          cycle;
    	        thfill (point t2 of P) --((point t of P) + symsize/2 * unitvector(thdir(P,t) rotated 90)) --
    	          (point t1 of P)--cycle withcolor (0, 0.7,0.9);
    	      fi;
    	      cur := cur + symsize;
    	      exitif cur > laenge - (1*symsize/3); % for rounding errors
    	      t1:=arctime (cur) of P;
    	    endfor;
    	    thdraw P withcolor (0, 0.7,0.9);
    	  enddef;

		  
def l_waterflow_permanent_MY (expr Path) =
  path ppp;
  T:=identity;
  cas := 0;
  dlzka := arclength Path;
  mojkrok:=adjust_step(dlzka, 0.5u);
    pickup PenD;
    vardef azim = 50 + 15*normaldeviate enddef;
    az1 := azim;
    sgn := 1;
    ppp := point 0 of Path;
    forever:
        t1 := arctime cas of Path;
        t2 := arctime (cas+mojkrok) of Path;
        if cas+1.1*mojkrok > dlzka:
            az2 := 0;
        else:
            az2 := azim;
        fi;
        d1 := angle(thdir(Path,t1)) + sgn * az1;
        d2 := angle(thdir(Path,t2)) - sgn * az2;
        ppp := ppp & (point t1 of Path){dir d1} .. {dir d2}(point t2 of Path);
        az1 := az2;
        sgn := -1 * sgn;
        cas := cas + mojkrok;
        exitif cas > dlzka + mojkrok/3;     % for rounding errors
    endfor;
%    drawarrow ppp;
    thdraw ppp;
    thdrawoptions();
    oldahlength:=ahlength;
    ahlength:=ahlength*optical_zoom;
	laength:= arclength ppp;
	anchr:= arctime (laength-0.1*mojkrok) of ppp;
	
	%thdraw (point anchr of ppp) -- (0,0);
	%d1 := unitvector(thdir(Path,(point anchr of Path)));
	thdraw (point anchr of ppp + (2*unitvector(thdir(ppp,anchr))) ) -- ((point anchr of ppp) + (0.66*unitvector(thdir(ppp,anchr)) rotated 90))--((point anchr of ppp) + (0.66*unitvector(thdir(ppp,anchr)) rotated -90))--cycle;
   thfill (point anchr of ppp + (2*unitvector(thdir(ppp,anchr))) ) -- ((point anchr of ppp) + (0.66*unitvector(thdir(ppp,anchr)) rotated 90))--((point anchr of ppp) + (0.66*unitvector(thdir(ppp,anchr)) rotated -90))--cycle;
    ahlength:=oldahlength;
enddef;

		# initialise new line symbols
		initsymbol("l_waterflow_permanent_MY")
	    initsymbol("l_u_overlay_MY");
	    initsymbol("l_u_mine_MY");
		initsymbol("l_u_deviation_MY");
	    initsymbol("l_u_underlay_MY");
	    initsymbol("l_u_fault");
	    initsymbol("l_u_icestep_MY");
	    initsymbol("l_u_icepit_MY");
	    initsymbol("l_u_wallstep");
	    initsymbol("l_u_bigpit_MY");
	    initsymbol("l_u_wallbigpit");
		initsymbol("l_u_icewallbigpit");
	    initsymbol("l_u_dripline");
			initsymbol("l_u_oldsnow_MY");
	    initsymbol("l_u_texture");
	    initsymbol("l_u_wall_flowstone");
		initsymbol("l_u_icepresumed");

endlayout

# define legend label
text en "line u:flowstone" "flowstone  wall"
text en "line u:openshaft_MY" "open shaft"
text en "line u:texture" "bedrock exposed"
text en "line u:wall_flowstone" "wall flowstone"
text en "line u:overlay_MY" "overlying passage"
text en "line u:mine_MY" "mine addit"
text en "line u:dripline" "dripline"
text en "line u:oldsnow_MY" "old snow level"
text en "line u:icepit_MY" "ice pit"


text fr "line u:flowstone" "paroi (concrétion)"
text fr "line u:texture" "texture de paroi"
text fr "line u:icepit_MY" "puits (glace)"
text fr "line u:icepresumed" "paroi présumée (glace)"
text fr "line u:deviation" "déviation"
text fr "line u:wallbigpit" "puits (entrée)"
text fr "line u:bigpit_MY" "puits"
text fr "line u:icestep_MY" "escarpement (glace)"
